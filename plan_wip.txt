Implementation Plan (v0.1)
==========================

Goals
- Ship a minimal but working Guard that monitors configured targets and enforces delays/blocks.
- Provide robust process detection via `scripts/pcheck.sh` (name, command, external) with clear tests.
- Establish on‑disk structure under `/opt/c4a` (ro settings, memory, logs) without requiring admin for local dev.

Milestones
0) Build System Setup
   - Introduce Autoconf/Automake scripts to compile Guard.
   - Acceptance: `./configure && make` builds Guard binary.
1) Bootstrap & Process Detection
   - Harden `scripts/pcheck.sh` (implement name/command/external; stub url for now).
   - Fix logging wrapper `scripts/c4a_script_logging` to use system `logger` correctly.
   - Acceptance: the three tests below return the shown PIDs (or empty if not running) and exit non‑zero on bad mode.

2) Guard Daemon Core
   - Ensure daemonization, syslog, and exit token handling are reliable (Guard already loops; keep `.g4exit`).
   - Add config loader stub (reads `/opt/c4a/protected/ro/app_settings/*.sqlv` later; for v0.1, allow a single JSON/TOML dev file in repo to simulate settings).
   - Periodic loop: call `pcheck.sh` for each configured target; write simple per‑target state file to memory dir.
   - Acceptance: Guard logs one loop/target to syslog; memory files update when processes appear/disappear.

3) Temperature Model (MVP)
   - Implement in Guard: `current_temperature`, `heat_rate`, `cool_rate`, `temperature_refresh_interval_in_seconds` for a single target.
   - Acceptance: temperature rises while detected, cools when not; persisted across loops.

4) Enforcement & Tasks (MVP)
   - For `always_blocked`, send a terminate signal to detected PIDs; for discourage, log intent (UI tasks later).
   - Acceptance: when `always_blocked=1`, detected processes are terminated within one loop.

5) Packaging & Profiles (later)
   - Provide install script that creates `/opt/c4a` tree and copies binaries/scripts; profile to launch Guard.
   - Code signing and entitlements follow after core is stable.

Directory Layout (target)
- `/opt/c4a/bin`        → `Guard`, helper scripts.
- `/opt/c4a/protected/ro/app_settings`    → read‑only per‑app config (SQLite or structured files).
- `/opt/c4a/protected/ro/global_settings` → global config.
- `/opt/c4a/protected/memory/app_memories`    → per‑app state (rw).
- `/opt/c4a/protected/memory/global_memories` → global state (rw).
- Exit token: `/opt/c4a/protected/com/.g4exit`.

Permissions and ACLs (requests.sqlite)
- Path: `/opt/c4a/protected/com/requests.sqlite` must be writable by user‑facing UIs (Status, BurnNotice) and readable by Guard.
- Recommended (group‑based):
  - `sudo mkdir -p /opt/c4a/protected/com`
  - `sudo chown guard:guard /opt/c4a/protected/com`
  - `sudo install -m 0660 /dev/null /opt/c4a/protected/com/requests.sqlite`
  - Create a group for UI users and grant group write:
    - `sudo dseditgroup -o create c4a_users` (macOS) or `sudo groupadd c4a_users` (Linux)
    - `sudo chgrp c4a_users /opt/c4a/protected/com /opt/c4a/protected/com/requests.sqlite`
    - `sudo chmod 0770 /opt/c4a/protected/com && sudo chmod 0660 /opt/c4a/protected/com/requests.sqlite`
    - Add each allowed user: `sudo dseditgroup -o edit -a $USER -t user c4a_users`
- Alternative (per‑user ACL on macOS):
  - `sudo chmod +a "user:$USER allow read,write,append,file_inherit" /opt/c4a/protected/com`
  - `sudo chmod +a "user:$USER allow read,write,append" /opt/c4a/protected/com/requests.sqlite`
- Guard should remain owner (`guard`) and keep restrictive defaults; avoid world‑writable. Ensure parent dir is not deletable by non‑privileged users.

Development Notes
- For local dev, simulate `/opt/c4a` with a workspace path and override via defines/env until install step exists.
- Prefer `pgrep -f` for command matching; keep `pgrep` name match simple.

Acceptance Tests (existing examples)
- Test 1: `scripts/pcheck.sh "command" "login -pfl andrewsmith /bin/bash -c exec -la zsh /bin/zsh"`
- Test 2: `scripts/pcheck.sh "name" "Steam"`
- Test 3: `scripts/pcheck.sh "external" "awk '/pid:/ {print $NF}' /private/tmp/gameoverlayui.log"`

—

Guard is intended to be configured manually at build time by a system admin, then set up according to the specifics of that install. 

It is intended to be protected from a local non-admin user and to be easily disabled and removed by someone with admin rights. 

To help protect it, we stick to configurations made at build time for those configs. It also can protect against 

ChallengeGuard lets you configure specific websites, apps, and binaries on your system to limit usage of. We will just call these "App" regardless of whether it is a binary, an app, or a website.

There is no max time or max opens; instead, each time you open it, you have to complete a challenge, and how hard that challenge is depends on the “temperature" of the app. That is based on how much you have used it recently, how many times it has been opened.  The app's “temperature" will increase with each launching or opening as well as more the longer it is open. (It gains more heat more quickly the longer it is used.)

When it is not open and the computer is running 



App and Web Delayer and Blocker for Mac OS Desktop

Users can block and/or discourage use of specific apps or websites from opening and to limit time used when those are opened without using hard limits on anything; that can all be configured by the user and then even frozen if they want.

Full blocking should be an option, but it's not the main point.

The main use is the delay and discourage use part.  Instead of just blocking something or adding a hurdle to use it and scale that hurdle based on a combination of factors that relate to how frequently it is used, how long, and what it is. The user makes all of these choices and can change them, but it should have options to set a hurdle to doing so such as needing to have admin rights on the system, a password, or a challenge just like opening an app.  The user can set the options to do things like require admin rights or a password, etc.; after once set, it takes doing them to change it again.

The settings data and other confirmation information should be stored in an area that can only be written to or changed by an administrator on the system. 

The program should not appear in the list of applications for force quit.

If the application is exited, it should be relaunched unless it is exited via using an exit button that will be located inside the settings panel and only accessible when it has been unlocked.  This can be achieved by launching, see /Users/andrewsmith/Desktop/projects/sensuser/Challenge4Access/App/Scripts/scripts/pcheck.sh
A profile use admin can install that will launch the app using that script.
/Users/andrewsmith/Desktop/projects/sensuser/Challenge4Access/App/Profiles/Challenge4Access.mobileconfig

The blocking needs to work across web browsers and without extensions, and this can be done with automation permission for the installed browsers and can be requested when set up and enabled by the user. 


Website blocking should follow this logic.

If I block/discourage/delay youtube.com, then m.youtuber.com and any other subdomains or variations are blocked/discouraged/delayed.
If I block/discourage/delay tv.apple.com, then apple.com is NOT blocked/discouraged/delayed.


Apps and binaries can be identified by either an example "Firefox” or the launch command as would be shown on the command column of the output of "ps aux" for example "/System/Library/Frameworks/CoreSpotlight.framework/spotlightknowledged -u", or by a command that can be used to find the PID if the app or binary is running.
	When the identification type is "name”, then the command "pgrep $value" should be used, where $value is the data stored in the entry for identification data.  

	When the identification type is "command”, then the command "ps aux | grep $value | grep -v grep | awk '{print $2}'" should be used, where $value is the data stored in the entry for identification data

	When the identification type is "external,” then the command "eval "$value"" should be used, where $value is the data stored in the entry for identification data.

An example script is at /Users/andrewsmith/Desktop/projects/sensuser/Challenge4Access/App/Scripts/scripts/pcheck.sh



Each thing, whether it is an app, website, or binary, that we have an entry for should also have a read-only "app_settings" file, a temporary memory file where we can store things for one cycle, a history file that keeps running totals and averages of use frequency and duration, and one readable memory file for global (impacts all).


The App settings directory should be the directory at APP_SETTINGS_DIR (defaults to "/opt/c4a/protected/ro/app_settings“).

Each .sqlv file will be loaded in that directory as an "app" (url, bin, on application).
Apps in the same sqlv file are in a "group" and should have their temperatures summed, and usage on one should increase the temperatures of all in the same group but mostly for the app being used.


When an app is opened, the value for sensitivity + the number of opens since the app was last at its starting temperature.

If the temperature for the app is below globaltemp, N is reduced by half of that percentage of that difference.

If the temperature for the app is above globaltemp, N is incremented by that percentage of that difference.

Then temperature * final_multiplier is passed to one of the enabled tasks.

If a 1 comes back, access is granted, and we start calculating the heart rate.  So long as the user exits before… 


cool_rate will be subtracted from the app's temperature once every temperature_refresh_interval_in_seconds when the app is closed not yet marked as cooled.

When the app reaches starting_temperature, then opens_since_last_cooled is reduced by 1 every temperature_refresh_interval_in_seconds until opens_since_last_cooled is 0. Then cooled is set to true.
When cooled is true for an app, if date_time_of_last_free_open was over 24 hours ago, it may be opened without any delay, although doing so warms it for the next time. So when the app first launched if cooled is true, and date_time_of_last_free_open was over 24 hours ago, set date_time_of_last_free_open to now and set cooled to false and give a free opening of the app.  If date_time_of_last_free_open was less than 24 hours ago, then a delay based on temperature is used.


heat_rate + sensitivity* (heat + opens_since_last_cooled) will be added to the app's temperature once every temperature_refresh_interval_in_seconds when the app is open.

Inside each file is an app, website, or binary to be monitored. They should begin with the same name that is the value of unique_id for that app. No two apps may have the same unique_id and if they do, we crash if _FAIL_ON_WARNINGS_ else we log it. We only take the first one with that ID we encounter. So additional ones with the same ID are ignored.  Log an error or if _FAIL_ON_WARNINGS_ is true crash.

if combustion_possible is true and temperature exceeds combustion_temp, then in the app memories we set burned to true.
	A burned app cannot be accessed. 


	 hours_remaining_until_not_burned in app memories to be equal to (recovery_length_in_hours_from_conbustion + opens_since_last_cooled + lifetime_numbr_of_times_burned), 



Each app is checked for every cycle_frequency_in_seconds seconds.

If seconds_of_usage_before_new_task is set to 0, then the user can use the app until combustion_temp without another task so long as they don't close it.
If seconds_of_usage_before_new_task is not 0, then that many seconds after starting the use the app, it will be closed and another task will need to be done using its not temperature.

Close it and they get a new task based on the new temperature.


If always_blocked is enabled, then the app will be forced closed or website blocked at all times. 


Read only per app, app settings
CREATE TABLE app_settings (
	unique_id INTEGER PRIMARY KEY AUTOINCREMENT UNIQUE NOT NULL DEFAULT '1',
	display_name STRING NOT NULL 'Name',
	trigger_id_type STRING NOT NULL,
	trigger_id_data STRING NOT NULL,
	always_blocked BOOLEAN NOT NULL DEFAULT '0',
	always_discouraged BOOLEAN NOT NULL DEFAULT '1',
	sensitivity FLOAT NOT NULL DEFAULT '3.0',
	starting_temperature FLOAT NOT NULL DEFAULT '1.0',
	heat_rate FLOAT NOT NULL DEFAULT '1.0',
	cool_rate FLOAT NOT NULL DEFAULT '0.05',
	seconds_of_usage_before_new_task INTEGER NOT NULL DEFAULT '300',
	temperature_refresh_interval_in_seconds FLOAT NOT NULL DEFAULT '60.0',
	heat FLOAT NOT NULL DEFAULT '0.15’,
	task_maths_available BOOLEAN NOT NULL DEFAULT '1',
 	task_lines_available BOOLEAN NOT NULL DEFAULT '1',
	task_clicks_available BOOLEAN NOT NULL DEFAULT '1',
	task_count_available BOOLEAN NOT NULL DEFAULT '1',
	conbustion_possible BOOLEAN NOT NULL DEFAULT '1',
	can_recover_from_conbustion_possible BOOLEAN NOT NULL DEFAULT '0',
	conbustion_temp FLOAT NOT NULL DEFAULT '3000.0',
	recovery_length_in_hours_from_conbustion INTEGER NOT NULL DEFAULT '72',
 );

A 0 for sensitivity or heat_rate is in effect turning off this aspect of the calculation and is also allowable but should trigger a visual change to ensure the user intends to turn these aspects off. A value of 0 for both sensitivity and heat_rate is also allowed and simply means that the difficulty of access will remain static, the dynamics are turned off for that one.

-- DROP TABLE app_memories;
CREATE TABLE app_memories (
	mID INTEGER PRIMARY KEY AUTOINCREMENT UNIQUE NOT NULL DEFAULT '1',
	app_unique_id STRING UNIQUE NOT NULL,
	cooled BOOLEAN NOT NULL DEFAULT '1',	
	last_seen_running_timestamp STRING,
	lifetime_opens INTEGER,
	opens_since_last_cooled INTEGER DEFAULT '0',
	date_time_of_last_free_open STRING,
	current_heat FLOAT NOT NULL DEFAULT '0.0',
	last_heat FLOAT NOT NULL DEFAULT '0.0',
	current_temperature FLOAT NOT NULL DEFAULT '1.0',
	last_open_time STRING,
	burned BOOLEAN NOT NULL DEFAULT '0',
	burned_forever BOOLEAN NOT NULL DEFAULT '0',
	lifetime_numbr_of_times_burned BOOLEAN NOT NULL DEFAULT '0',
	hours_remaining_until_not_burned FLOAT DEFAULT '0’,
	last_burned_date_time STRING 
 );


CREATE TABLE globsl_settings (
	unique_id INTEGER PRIMARY KEY AUTOINCREMENT UNIQUE NOT NULL DEFAULT '1',
	cycle_frequency_in_seconds INTEGER NOT NULL,
	final_multiplier FLOAT NOT NULL DEFAULT '1.05',
	globaltemp FLOAT NOT NULL DEFAULT '1.0‘,
	can_fail_tasks BOOLEAN NOT NULL DEFAULT '1',
	grade_tasks BOOLEAN NOT NULL DEFAULT '1',
	min_grade_to_pass FLOAT NOT NULL DEFAULT '0.95'
	ambient_temp FLOAT NOT NULL DEFAULT '1.0',
	early_exit_enforment BOOLEAN NOT NULL DEFAULT '1',
	early_exit_multiplyer FLOAT NOT NULL DEFAULT '10.0',
	failed_multiplyer FLOAT NOT NULL DEFAULT '1.5');

ambient_temp is the average of all of the temperatures of apps that do not have cooled set to true. 


N is calculated. 

Each task category has read-only settings such as this one for math.

Each task will accepts and expects CLI Arguments as follows

Argumnet 1 is N (hw hard and logn the task will be)
Argument 2 is grade_tasks and should be set to the value of grade_tasks from globsl_settings by  guard when launchung the task. Shold be 1 or 0 defaults to 1
Argument 3 is min_grade_to_pass and should be set to the value of grade_tasks from min_grade_to_pass  by  guard when launchung the task. Shold be  between 1 or 0 defaults to 0.95

IF reset_immediatly_on_fail is true, then the moment that ((current_N_owned_total - current_N_compleated) * the_problems_per_n_for_the_expected_problem_type) + current_score / max_possible_score) * 100 < min_grade_to_pass * 100, a score of 0 is returned as a failure.

IF reset_immediatly_on_fail is false, the score is not calculated until current_N_compleated > current_N_owned_total.


When 0 is returned from the task, if can_fail_tasks is false then we simply require the user to redo the task to proced or decide not run the app they wanted to use right now. 
When 1 is returned from the task, if can_fail_tasks is true or not set then we add multiply the app's tempature by failed_multiplyer for the app listed under last_task_was_for_access_to_app_unique_id,  current_N_owned_total to  current_N_owned_total * failed_multiplyer ,  set current_score to 0, current_N_compleated to 0, update task_started_at to now, and set process_ended_without_pass_or_fail to false, then start the task again with the new parameters.


If the PID for the task vanishes but no score is returned (we did not get a 1 or 0 back) and the globale setting early_exit_enforment is true or not set, then 
	Guard should and must mark the app listed under last_task_was_for_access_to_app_unique_id as burned, set the burn time, and multiply current_N_owned_total by early_exit_multiplyer, set current_score to 0, current_N_compleated to 0, update task_started_at to now, and set process_ended_without_pass_or_fail to false, then start the task again with the new parameters.
They should return either 1 or 0. 
	It shold return 1 if the task was completed correctly with a passing score or better if grade_tasks was 1.
	It shold return 1 if the task was completed perfectly with no errors if grade_tasks was 0.  (grading makes it easier, it allows you do mess up some on the task so long as your grade is passing you pass)
	In all other cases it should retun 0 if the exit was normal and happend at because the task was finished.
	It shold try to return -1  in all other cases.

See These Other REDME files, this list shuold grow as subprojects are added
/Users/andrewsmith/Desktop/projects/sensuser/Challenge4Access/Challenge4Access/tasks/README

/Users/andrewsmith/Desktop/projects/sensuser/Challenge4Access/Challenge4Access/tasks/academic/math/README


